// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package gemini

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// Audio input message from client
type ClientInputAudioJson struct {
	// Base64-encoded audio data chunk
	Chunk string `json:"chunk" yaml:"chunk" mapstructure:"chunk"`

	// Whether this is the final chunk in the audio stream
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// Audio format
	Format ClientInputAudioJsonFormat `json:"format" yaml:"format" mapstructure:"format"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ClientInputAudioJsonFormat string

const ClientInputAudioJsonFormatOpus ClientInputAudioJsonFormat = "opus"
const ClientInputAudioJsonFormatPcm16 ClientInputAudioJsonFormat = "pcm16"
const ClientInputAudioJsonFormatWav ClientInputAudioJsonFormat = "wav"

var enumValues_ClientInputAudioJsonFormat = []interface{}{
	"wav",
	"pcm16",
	"opus",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClientInputAudioJsonFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ClientInputAudioJsonFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ClientInputAudioJsonFormat, v)
	}
	*j = ClientInputAudioJsonFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClientInputAudioJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["chunk"]; raw != nil && !ok {
		return fmt.Errorf("field chunk in ClientInputAudioJson: required")
	}
	if _, ok := raw["final"]; raw != nil && !ok {
		return fmt.Errorf("field final in ClientInputAudioJson: required")
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in ClientInputAudioJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClientInputAudioJson: required")
	}
	type Plain ClientInputAudioJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClientInputAudioJson(plain)
	return nil
}

// Text input message from client
type ClientInputTextJson struct {
	// The text content
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Optional turn identifier for conversation tracking
	TurnId *string `json:"turnId,omitempty" yaml:"turnId,omitempty" mapstructure:"turnId,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClientInputTextJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in ClientInputTextJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClientInputTextJson: required")
	}
	type Plain ClientInputTextJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClientInputTextJson(plain)
	return nil
}

// Error response message
type ErrorJson struct {
	// Error code identifier
	Code string `json:"code" yaml:"code" mapstructure:"code"`

	// Human-readable error message
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ErrorJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ErrorJson: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in ErrorJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ErrorJson: required")
	}
	type Plain ErrorJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ErrorJson(plain)
	return nil
}

// Function/tool invocation from server
type FunctionCallJson struct {
	// Arguments to pass to the function
	Arguments map[string]interface{} `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// Unique identifier for the function call
	CallId string `json:"callId" yaml:"callId" mapstructure:"callId"`

	// Name of the function to call
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FunctionCallJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in FunctionCallJson: required")
	}
	if _, ok := raw["callId"]; raw != nil && !ok {
		return fmt.Errorf("field callId in FunctionCallJson: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in FunctionCallJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in FunctionCallJson: required")
	}
	type Plain FunctionCallJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = FunctionCallJson(plain)
	return nil
}

// Audio output message from server
type ServerOutputAudioJson struct {
	// Base64-encoded audio data chunk
	Chunk string `json:"chunk" yaml:"chunk" mapstructure:"chunk"`

	// Whether this is the final chunk in the audio stream
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// Audio format
	Format ServerOutputAudioJsonFormat `json:"format" yaml:"format" mapstructure:"format"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ServerOutputAudioJsonFormat string

const ServerOutputAudioJsonFormatOpus ServerOutputAudioJsonFormat = "opus"
const ServerOutputAudioJsonFormatPcm16 ServerOutputAudioJsonFormat = "pcm16"
const ServerOutputAudioJsonFormatWav ServerOutputAudioJsonFormat = "wav"

var enumValues_ServerOutputAudioJsonFormat = []interface{}{
	"wav",
	"pcm16",
	"opus",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServerOutputAudioJsonFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ServerOutputAudioJsonFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ServerOutputAudioJsonFormat, v)
	}
	*j = ServerOutputAudioJsonFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServerOutputAudioJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["chunk"]; raw != nil && !ok {
		return fmt.Errorf("field chunk in ServerOutputAudioJson: required")
	}
	if _, ok := raw["final"]; raw != nil && !ok {
		return fmt.Errorf("field final in ServerOutputAudioJson: required")
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in ServerOutputAudioJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ServerOutputAudioJson: required")
	}
	type Plain ServerOutputAudioJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ServerOutputAudioJson(plain)
	return nil
}

// Text output message from server
type ServerOutputTextJson struct {
	// Whether this is the final text output
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// The text content
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServerOutputTextJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["final"]; raw != nil && !ok {
		return fmt.Errorf("field final in ServerOutputTextJson: required")
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in ServerOutputTextJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ServerOutputTextJson: required")
	}
	type Plain ServerOutputTextJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ServerOutputTextJson(plain)
	return nil
}

// Session termination message
type SessionEndJson struct {
	// Reason for ending the session
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SessionEndJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in SessionEndJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SessionEndJson: required")
	}
	type Plain SessionEndJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SessionEndJson(plain)
	return nil
}

// Session resumption token message
type SessionResumptionUpdateJson struct {
	// Resumption handle for session continuity
	Handle string `json:"handle" yaml:"handle" mapstructure:"handle"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SessionResumptionUpdateJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["handle"]; raw != nil && !ok {
		return fmt.Errorf("field handle in SessionResumptionUpdateJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SessionResumptionUpdateJson: required")
	}
	type Plain SessionResumptionUpdateJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SessionResumptionUpdateJson(plain)
	return nil
}

// Initial session configuration message
type SetupRequestJson struct {
	// The model to use for the session
	Model string `json:"model" yaml:"model" mapstructure:"model"`

	// Optional session configuration parameters
	SessionConfig map[string]interface{} `json:"sessionConfig,omitempty" yaml:"sessionConfig,omitempty" mapstructure:"sessionConfig,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetupRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["model"]; raw != nil && !ok {
		return fmt.Errorf("field model in SetupRequestJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SetupRequestJson: required")
	}
	type Plain SetupRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetupRequestJson(plain)
	return nil
}

// Result of tool/function execution
type ToolResultJson struct {
	// Unique identifier for the tool call
	CallId string `json:"callId" yaml:"callId" mapstructure:"callId"`

	// Name of the tool that was executed
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Result data from tool execution
	Result interface{} `json:"result" yaml:"result" mapstructure:"result"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolResultJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["callId"]; raw != nil && !ok {
		return fmt.Errorf("field callId in ToolResultJson: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolResultJson: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in ToolResultJson: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolResultJson: required")
	}
	type Plain ToolResultJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolResultJson(plain)
	return nil
}
